import java.util.*;

/**
 * A static-method class reponsible for capturing neutral planets.
 */
public class Explorer {
	public static void explore(PlanetWars pw) {
		//empiric factor, to be tuned
		int aggro = 1000/(13+pw.myForces/100);
		//find the forsaken
		List<Planet> forsaken = new ArrayList<Planet>();
		for (Planet p : pw.planets) {
	    	if (p.owner == 0)
	   		if (juicyness(p) > aggro)
	   		if (p.incoming.size() == 0) {
	   			forsaken.add(p);
	   		}
		}
		//order of relevance
		Comparator<Planet> comparator = new Comparator<Planet>()
{public int compare(Planet p1, Planet p2){return juicyness(p2)-juicyness(p1);}};
		Collections.sort(forsaken,comparator);
		
		//filter and capture
		for (Planet p : forsaken) {
			for (Planet source : pw.MyClosestPlanets(p)) if (p.numShips < source.safety) {
				int distance = PlanetWars.Distance(source,p);
				boolean safe = true;
				for (Planet pe : pw.planets)
					if ((pe.owner >= 2) && (PlanetWars.Distance(p,pe) <= distance))
							{safe = false; break;}
				if (safe) {pw.IssueOrder(source,p,p.numShips+1);break;}
			}
		}
	}
	
	public static void expand(PlanetWars pw) {
		int aggro = 1000/25;
		List<Planet> targets = new ArrayList<Planet>();
		for (Planet p : pw.planets)
	    	if ( (p.owner == 0) && (juicyness(p) > aggro) && (p.incoming.size() == 0) )
	   			targets.add(p);
	   	for (Planet p : pw.planets) {} //TODO: anything at all
	}
	
	public static int juicyness(Planet p) {
		//empiric factor, to be tuned
		return p.growthRate*1000/p.numShips;
	}
}
